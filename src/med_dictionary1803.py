from __future__ import annotations
# -*- coding: utf-8 -*-
"""med_dictionary1803.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18EnlT3P1CKTW3_eU0k1Z-2rIg-RDmwx6
"""



"""
med_dictionary.py - Medication dictionary for SSRI and SNRI medications

A clean, simple dictionary of SSRI and SNRI medications with both brand and generic names.
Includes utilities for loading, updating, and backing up medication data.

Usage:
    from med_dictionary import MedDictionary
    meds = MedDictionary()
    meds.get_all_medication_names()  # Returns all medication names for Reddit queries
"""


import os
import json
import csv
import shutil
import logging
import datetime
import re
from pathlib import Path
from typing import Dict, List, Set, Optional, Any, Tuple
from collections import defaultdict
from enum import Enum
from dataclasses import dataclass, field, asdict

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("med_dictionary.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("med_dictionary")

class DrugClass(Enum):
    """Enumeration of psychiatric medication classes"""
    SSRI = "ssri"
    SNRI = "snri"
    ATYPICAL_ANTIPSYCHOTIC = "atypical_antipsychotic"
    NDRI = "ndri"  # For bupropion
    SARI = "sari"  # For mirtazapine
    TCA = "tca"  # Tricyclic antidepressants
    MAOI = "maoi"  # Monoamine oxidase inhibitors
    MOOD_STABILIZER = "mood_stabilizer"
    BENZODIAZEPINE = "benzodiazepine"
    STIMULANT = "stimulant"
    OTHER = "other"

    @classmethod
    def get_all_values(cls) -> List[str]:
        """Return all enum values as strings"""
        return [member.value for member in cls]

@dataclass
class Medication:
    """Structured data class for medication information"""
    generic_name: str
    brand_names: List[str] = field(default_factory=list)
    drug_class: str = ""
    aliases: List[str] = field(default_factory=list)
    notes: str = ""

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for storage"""
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> Medication:
        """Create instance from dictionary"""
        return cls(**data)

class MedDictionary:
    """
    Dictionary of SSRI and SNRI medications for use in Reddit data collection
    """

    VERSION = "1.0.0"

    # Common misspellings and abbreviations
    COMMON_MISSPELLINGS = {
        # SSRI misspellings
        'prozak': 'prozac',
        'prosac': 'prozac',
        'lexaporo': 'lexapro',
        'zolof': 'zoloft',
        'zolofot': 'zoloft',
        'paxill': 'paxil',
        'celexa': 'citalopram',
        
        # SNRI misspellings
        'effexor xr': 'effexor',
        'venlafaxin': 'venlafaxine',
        'pristiq': 'desvenlafaxine',
        'cymbalta': 'duloxetine',
        'dulox': 'duloxetine',
        
        # Common abbreviations
        'ssri': 'ssri',
        'snri': 'snri',
        'maoi': 'maoi',
        'tca': 'tca'
    }

    # Brand to generic mappings
    GENERIC_ALIASES = {
        'prozac': ['fluoxetine'],
        'zoloft': ['sertraline'],
        'lexapro': ['escitalopram'],
        'paxil': ['paroxetine'],
        'celexa': ['citalopram'],
        'cymbalta': ['duloxetine'],
        'effexor': ['venlafaxine', 'effexor xr'],
        'pristiq': ['desvenlafaxine'],
        'wellbutrin': ['bupropion', 'zyban'],
        'abilify': ['aripiprazole'],
        'seroquel': ['quetiapine'],
        'zyprexa': ['olanzapine'],
        'latuda': ['lurasidone'],
        'rexulti': ['brexpiprazole'],
        'geodon': ['ziprasidone']
    }

    def __init__(self, auto_load: bool = True):
        """
        Initialize the medication dictionary

        Args:
            auto_load: If True, automatically load dictionary from file
        """
        # Path resolution relative to this module
        self.MODULE_DIR = Path(__file__).resolve().parent
        self.DATA_DIR = self.MODULE_DIR / "med_data"
        self.BACKUP_DIR = self.DATA_DIR / "backups"
        self.PRIMARY_FILE = self.DATA_DIR / "medications.json"
        self.DEFAULT_DATA_FILE = self.DATA_DIR / "default_meds_v1.csv"
        self.SUBREDDIT_FILE = self.DATA_DIR / "subreddits.json"

        # Main dictionaries
        self.medications: Dict[str, Medication] = {}
        self.generic_to_brands: Dict[str, List[str]] = {}
        self.brand_to_generic: Dict[str, str] = {}
        self.all_names: Set[str] = set()
        self.name_to_generic: Dict[str, str] = {}
        self.subreddits: Dict[str, List[str]] = {
            "medication_specific": [],
            "general": []
        }

        # Track medication classes using defaultdict
        self.classes = defaultdict(list)
        # Initialize known classes (though defaultdict would create on demand)
        for drug_class in DrugClass:
            self.classes[drug_class.value] = []

        # Metadata
        self.last_updated = datetime.datetime.now().isoformat()
        self.version = self.VERSION

        # Pre-compiled regex pattern for medication matching
        self.med_regex = None

        # Ensure directories exist
        self.DATA_DIR.mkdir(parents=True, exist_ok=True)
        self.BACKUP_DIR.mkdir(parents=True, exist_ok=True)

        # Initialize with default data or load from file
        if auto_load:
            if self.PRIMARY_FILE.exists():
                self.load()
            else:
                self.load_default_data()
                self.save()  # Save the default data to JSON for future use
            
            # Load subreddits
            self.load_subreddits()
            
            # Initialize name mappings
            self._initialize_name_mappings()
            
            # Compile regex pattern after loading medications
            self._compile_regex_pattern()

    def _initialize_name_mappings(self) -> None:
        """Initialize name to generic mappings for all known medications"""
        # Clear existing mappings
        self.name_to_generic.clear()
        
        # Add generic names
        for generic_name in self.medications:
            self.name_to_generic[generic_name] = generic_name
            
        # Add brand names and aliases
        for generic_name, medication in self.medications.items():
            for brand in medication.brand_names:
                self.name_to_generic[brand] = generic_name
            for alias in medication.aliases:
                self.name_to_generic[alias] = generic_name
                
        # Add generic aliases
        for brand, generics in self.GENERIC_ALIASES.items():
            for generic in generics:
                self.name_to_generic[brand] = generic
                self.name_to_generic[generic] = generic
                
        # Add misspellings
        for wrong, correct in self.COMMON_MISSPELLINGS.items():
            if correct in self.name_to_generic:
                self.name_to_generic[wrong] = self.name_to_generic[correct]
            else:
                self.name_to_generic[wrong] = correct

    def _generate_name_variants(self, name: str) -> List[str]:
        """
        Generate variants of a medication name including plurals and possessives.
        
        Args:
            name: Base medication name
            
        Returns:
            List of name variants
        """
        variants = [name]
        
        # Add plural forms
        if name.endswith('y'):
            variants.append(name[:-1] + 'ies')  # e.g., "prozacy" -> "prozacies"
        else:
            variants.append(name + 's')  # e.g., "prozac" -> "prozacs"
            
        # Add possessive forms
        variants.append(name + "'s")  # e.g., "prozac" -> "prozac's"
        
        # Add common misspellings
        if name in self.COMMON_MISSPELLINGS:
            variants.append(self.COMMON_MISSPELLINGS[name])
            
        return variants

    def _compile_regex_pattern(self) -> None:
        """Compile regex pattern for medication matching with support for variants"""
        if not self.all_names:
            self.med_regex = None
            return
            
        # Generate variants for all names
        all_variants = set()
        for name in self.all_names:
            all_variants.update(self._generate_name_variants(name))
            
        # Sort names by length (descending) to match longer names first
        sorted_names = sorted(all_variants, key=len, reverse=True)
        
        # Create pattern that matches word boundaries
        pattern = r'\b(?:' + '|'.join(map(re.escape, sorted_names)) + r')\b'
        self.med_regex = re.compile(pattern, re.IGNORECASE)

    def _add_medication(self, med_data: Dict[str, Any]) -> None:
        """
        Add a medication to the dictionary, ensuring all strings are lowercase

        Args:
            med_data: Dictionary containing medication information

        Raises:
            ValueError: If the medication name already exists or if there are name conflicts
        """
        # Create Medication instance and normalize data
        generic_name = med_data["generic_name"].lower()

        # Check for duplicate generic name
        if generic_name in self.medications:
            raise ValueError(f"Duplicate generic name: '{generic_name}' already exists in the dictionary")

        # Normalize brand names
        brand_names = [brand.lower() for brand in med_data.get("brand_names", [])]

        # Check for brand name conflicts
        for brand in brand_names:
            if brand in self.brand_to_generic and self.brand_to_generic[brand] != generic_name:
                raise ValueError(f"Brand name conflict: '{brand}' is already associated with '{self.brand_to_generic[brand]}'")

        # Normalize aliases
        aliases = [alias.lower() for alias in med_data.get("aliases", [])]

        # Check for alias conflicts
        for alias in aliases:
            if alias in self.all_names:
                raise ValueError(f"Alias conflict: '{alias}' already exists as another medication name or alias")

        # Normalize drug class
        drug_class = med_data["drug_class"].lower()

        # Validate drug class is valid
        if drug_class not in DrugClass.get_all_values():
            logger.warning(f"Unknown drug class: '{drug_class}' - will be added as a new class")

        # Create Medication instance
        medication = Medication(
            generic_name=generic_name,
            brand_names=brand_names,
            drug_class=drug_class,
            aliases=aliases,
            notes=med_data.get("notes", "")
        )

        # Store the normalized medication data
        self.medications[generic_name] = medication

        # Update mapping dictionaries
        self.generic_to_brands[generic_name] = brand_names
        for brand in brand_names:
            self.brand_to_generic[brand] = generic_name

        # Add to all names set (for searching)
        self.all_names.add(generic_name)
        self.all_names.update(brand_names)
        self.all_names.update(aliases)

        # Add to class lists (using defaultdict, so it works for any class)
        self.classes[drug_class].append(generic_name)
        
        # Recompile regex pattern after adding new medication
        self._compile_regex_pattern()

    def _create_minimal_defaults(self) -> None:
        """Create minimal default data when no file is available"""
        # Add just a couple of essential medications
        self._add_medication({
            "generic_name": "fluoxetine",
            "brand_names": ["prozac"],
            "drug_class": "ssri",
            "aliases": ["flx"]
        })

        self._add_medication({
            "generic_name": "venlafaxine",
            "brand_names": ["effexor"],
            "drug_class": "snri",
            "aliases": ["ven"]
        })

        logger.info("Created minimal default medication data")

    def load_default_data(self, default_file: Optional[Path] = None) -> None:
        """
        Load default medication data from external file

        Args:
            default_file: Path to default medication file (CSV or JSON)
                          If None, uses the default path
        """
        # Determine default path if none provided
        if default_file is None:
            default_file = self.DEFAULT_DATA_FILE

        # Check if file exists
        if not default_file.exists():
            logger.warning(f"Default medications file not found: {default_file}")
            logger.info("Creating minimal default data")
            self._create_minimal_defaults()
            # Export the minimal data for future use
            default_file.parent.mkdir(parents=True, exist_ok=True)
            self.export_default_data(default_file)
            return

        # Load based on file extension
        file_ext = default_file.suffix.lower()
        if file_ext == '.csv':
            self.import_csv(default_file)
            logger.info(f"Loaded default medications from CSV: {default_file}")
        elif file_ext == '.json':
            self.import_json(default_file)
            logger.info(f"Loaded default medications from JSON: {default_file}")
        else:
            logger.error(f"Unsupported file format: {file_ext}")
            self._create_minimal_defaults()

    def export_default_data(self, output_file: Optional[Path] = None) -> bool:
        """
        Export the current medication data as default data

        Args:
            output_file: Path to output file. If None, uses standard default path
        """
        if output_file is None:
            output_file = self.DEFAULT_DATA_FILE

        # Determine export format based on extension
        file_ext = output_file.suffix.lower()
        if file_ext == '.csv':
            self.export_csv(output_file)
        elif file_ext == '.json':
            self.export_json(output_file)
        else:
            logger.error(f"Unsupported file format: {file_ext}")
            return False

        logger.info(f"Exported default medications to {output_file}")
        return True

    def save(self, backup: bool = True) -> None:
        """
        Save the medication dictionary to file

        Args:
            backup: If True, create a backup of the existing file
        """
        # Create backup if requested
        if backup and self.PRIMARY_FILE.exists():
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_file = self.BACKUP_DIR / f"medications_{timestamp}.json"
            shutil.copy2(self.PRIMARY_FILE, backup_file)
            logger.info(f"Created backup at {backup_file}")

        # Update metadata
        self.last_updated = datetime.datetime.now().isoformat()

        # Convert medication objects to dictionaries
        meds_dict = {
            name: med.to_dict() for name, med in self.medications.items()
        }

        # Prepare data for serialization
        data = {
            "medications": meds_dict,
            "metadata": {
                "version": self.version,
                "last_updated": self.last_updated,
                "medication_count": len(self.medications),
                "ssri_count": len(self.classes["ssri"]),
                "snri_count": len(self.classes["snri"])
            }
        }

        # Write to file
        with open(self.PRIMARY_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2)

        logger.info(f"Saved medication dictionary to {self.PRIMARY_FILE}")

    def load(self) -> bool:
        """
        Load the medication dictionary from file

        Returns:
            bool: True if successful, False otherwise
        """
        try:
            with open(self.PRIMARY_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)

            # Clear existing data
            self.medications.clear()
            self.generic_to_brands.clear()
            self.brand_to_generic.clear()
            self.all_names.clear()
            for class_name in self.classes:
                self.classes[class_name] = []

            # Load metadata
            metadata = data.get("metadata", {})
            self.version = metadata.get("version", self.VERSION)
            self.last_updated = metadata.get("last_updated", datetime.datetime.now().isoformat())

            # Load medications
            for generic_name, med_data in data.get("medications", {}).items():
                try:
                    self._add_medication(med_data)
                except ValueError as e:
                    logger.warning(f"Skipped medication {generic_name} during load: {e}")

            logger.info(f"Loaded {len(self.medications)} medications from {self.PRIMARY_FILE}")
            return True

        except Exception as e:
            logger.error(f"Failed to load medication dictionary: {e}")
            return False

    def _pretty_print_drug_name(self, name: str) -> str:
        """Format drug name with proper capitalization for display"""
        # Common patterns: capitalize first letter of each word
        # Special cases: acronyms like SSRI, SNRI should be uppercase
        if name.upper() in ['SSRI', 'SNRI', 'MAO', 'MAOI', 'TCA']:
            return name.upper()
        else:
            return name.title()

    def export_csv(self, filename: Path | str, use_pretty_names: bool = True) -> None:
        """
        Export the medication list to a CSV file

        Args:
            filename: Path to the output CSV file
            use_pretty_names: If True, format names with proper capitalization
        """
        with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = ['generic_name', 'brand_names', 'drug_class', 'aliases', 'notes']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

            writer.writeheader()
            for generic_name, medication in self.medications.items():
                # Format names if requested
                if use_pretty_names:
                    row = {
                        'generic_name': self._pretty_print_drug_name(generic_name),
                        'brand_names': ', '.join([self._pretty_print_drug_name(b) for b in medication.brand_names]),
                        'drug_class': medication.drug_class.upper() if medication.drug_class.upper() in ['SSRI', 'SNRI'] else medication.drug_class,
                        'aliases': ', '.join(medication.aliases),
                        'notes': medication.notes
                    }
                else:
                    row = {
                        'generic_name': generic_name,
                        'brand_names': ', '.join(medication.brand_names),
                        'drug_class': medication.drug_class,
                        'aliases': ', '.join(medication.aliases),
                        'notes': medication.notes
                    }
                writer.writerow(row)

        logger.info(f"Exported medication list to {filename}")

    def export_json(self, filename: Path | str) -> None:
        """
        Export the medication list to a JSON file

        Args:
            filename: Path to the output JSON file
        """
        # Prepare data for export
        meds_dict = {
            name: med.to_dict() for name, med in self.medications.items()
        }

        export_data = {
            "medications": meds_dict,
            "metadata": {
                "version": self.version,
                "exported_at": datetime.datetime.now().isoformat(),
                "medication_count": len(self.medications)
            }
        }

        # Write to file
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(export_data, f, indent=2)

        logger.info(f"Exported medication list to {filename}")

    def import_json(self, filename: Path | str) -> bool:
        """
        Import medications from a JSON file

        Args:
            filename: Path to the input JSON file

        Returns:
            bool: True if successful, False otherwise
        """
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                data = json.load(f)

            # Import medications
            skipped_items = []
            success_count = 0

            for generic_name, med_data in data.get("medications", {}).items():
                try:
                    # Convert to Medication object if necessary
                    if not isinstance(med_data, dict):
                        logger.warning(f"Invalid medication data format for {generic_name}")
                        continue

                    self._add_medication(med_data)
                    success_count += 1
                except ValueError as e:
                    # Log the error and skip this medication
                    logger.warning(f"Skipped medication {generic_name}: {e}")
                    skipped_items.append((generic_name, str(e)))

            # Report results
            if skipped_items:
                logger.warning(f"Imported {success_count} medications, skipped {len(skipped_items)} with errors")
                for name, error in skipped_items:
                    logger.warning(f"  {name}: {error}")
            else:
                logger.info(f"Successfully imported all {success_count} medications from {filename}")

            return success_count > 0

        except Exception as e:
            logger.error(f"Failed to import medications from JSON: {e}")
            return False

    def get_all_medication_names(self) -> List[str]:
        """
        Get a list of all medication names for Reddit queries

        Returns:
            List of all medication names (generic, brand, and aliases)
        """
        return list(self.all_names)

    def get_query_terms(self) -> List[str]:
        """
        Get optimized query terms for Reddit searches

        Returns:
            List of optimized query terms
        """
        # For Reddit search, we want to use the most common terms
        # but avoid redundant searches
        query_terms = []

        # Add all generic names and major brand names
        for generic, medication in self.medications.items():
            query_terms.append(generic)

            # Add the first (usually most well-known) brand name
            if medication.brand_names:
                query_terms.append(medication.brand_names[0].lower())

        return query_terms

    def get_medication_class(self, med_name: str) -> Optional[str]:
        """
        Get the class of a medication by name

        Args:
            med_name: Generic name, brand name, or alias

        Returns:
            Medication class or None if not found
        """
        med_name = med_name.lower()

        # Check if it's a generic name
        if med_name in self.medications:
            return self.medications[med_name].drug_class

        # Check if it's a brand name
        if med_name in self.brand_to_generic:
            generic = self.brand_to_generic[med_name]
            return self.medications[generic].drug_class

        # Check aliases
        for generic, medication in self.medications.items():
            if med_name in medication.aliases:
                return medication.drug_class

        return None

    def get_generic_name(self, med_name: str) -> Optional[str]:
        """
        Get the generic name for any medication name

        Args:
            med_name: Generic name, brand name, or alias

        Returns:
            Generic name or None if not found
        """
        return self.name_to_generic.get(med_name.lower())

    def find_medication_mentions(self, text: str) -> List[str]:
        """
        Find all medication mentions in a text using pre-compiled regex pattern

        Args:
            text: Text to search for medication mentions

        Returns:
            List of generic medication names found
        """
        if not isinstance(text, str) or not self.med_regex:
            return []

        text = text.lower()
        found_meds = set()

        # Use pre-compiled regex pattern to find all matches
        for match in self.med_regex.finditer(text):
            med_name = match.group(0).lower()
            generic = self.get_generic_name(med_name)
            if generic:
                found_meds.add(generic)

        return list(found_meds)

    def load_subreddits(self) -> bool:
        """
        Load subreddit list from file or create default if not exists

        Returns:
            True if successful, False otherwise
        """
        try:
            if self.SUBREDDIT_FILE.exists():
                with open(self.SUBREDDIT_FILE, 'r') as f:
                    self.subreddits = json.load(f)
                logger.info(f"Loaded {len(self.subreddits['medication_specific'])} medication-specific and {len(self.subreddits['general'])} general subreddits")
                return True
            else:
                # Create default subreddit list
                self.subreddits = {
                    "medication_specific": [
                        "prozac",
                        "zoloft",
                        "lexapro",
                        "celexa",
                        "paxil",
                        "effexor",
                        "cymbalta",
                        "wellbutrin"
                    ],
                    "general": [
                        "antidepressants",
                        "anxiety",
                        "depression",
                        "mentalhealth",
                        "psychiatry",
                        "psychology",
                        "SSRIs",
                        "SNRIs"
                    ]
                }
                self.save_subreddits()
                logger.info("Created default subreddit list")
                return True
        except Exception as e:
            logger.error(f"Error loading subreddits: {e}")
            return False

    def save_subreddits(self) -> bool:
        """
        Save subreddit list to file

        Returns:
            True if successful, False otherwise
        """
        try:
            with open(self.SUBREDDIT_FILE, 'w') as f:
                json.dump(self.subreddits, f, indent=2)
            logger.info(f"Saved subreddit list to {self.SUBREDDIT_FILE}")
            return True
        except Exception as e:
            logger.error(f"Error saving subreddits: {e}")
            return False

    def get_subreddits(self) -> Dict[str, List[str]]:
        """
        Get the list of subreddits to search

        Returns:
            Dictionary with 'medication_specific' and 'general' subreddit lists
        """
        return self.subreddits

# Example usage
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Medication Dictionary Management")
    parser.add_argument('--create-default', action='store_true', help="Create default medications file")
    parser.add_argument('--export', help="Export medications to file (CSV or JSON)")
    parser.add_argument('--import-file', help="Import medications from file (CSV or JSON)")
    parser.add_argument('--display-classes', action='store_true', help="Display all medication classes")
    parser.add_argument('--find-meds', help="Find medications mentioned in a text file")
    args = parser.parse_args()

    if args.create_default:
        # Create default data file if it doesn't exist
        med_dict = MedDictionary(auto_load=False)
        if not os.path.exists(med_dict.DATA_DIR):
            # Add some basic default medications
            med_dict._add_medication({
                "generic_name": "fluoxetine",
                "class": "ssri",
                "brand_names": ["prozac"],
                "aliases": ["prozac", "sarafem"]
            })
            med_dict._add_medication({
                "generic_name": "sertraline",
                "class": "ssri",
                "brand_names": ["zoloft"],
                "aliases": ["zoloft", "lustral"]
            })
            med_dict._add_medication({
                "generic_name": "venlafaxine",
                "class": "snri",
                "brand_names": ["effexor"],
                "aliases": ["effexor", "effexor xr"]
            })
            med_dict.export_default_data()  # Export to default file
            print(f"Created default medications file in {med_dict.DATA_DIR}")
        else:
            print(f"Default medications file already exists in {med_dict.DATA_DIR}")
    elif args.export:
        # Export to specified file
        med_dict = MedDictionary()
        if str(args.export).endswith('.csv'):
            med_dict.export_csv(args.export)
        elif str(args.export).endswith('.json'):
            med_dict.export_json(args.export)
        else:
            print(f"Unsupported export format: {args.export}")
            print("Supported formats: .csv, .json")
    elif args.import_file:
        # Import from specified file
        med_dict = MedDictionary(auto_load=False)
        if str(args.import_file).endswith('.csv'):
            success = med_dict.import_csv(args.import_file)
        elif str(args.import_file).endswith('.json'):
            success = med_dict.import_json(args.import_file)
        else:
            success = False
            print(f"Unsupported import format: {args.import_file}")
            print("Supported formats: .csv, .json")

        if success:
            med_dict.save()
            print(f"Imported {len(med_dict.medications)} medications")
    elif args.display_classes:
        # Display all medication classes
        med_dict = MedDictionary()
        print("Medication Classes:")
        for class_name, meds in med_dict.classes.items():
            if meds:  # Only show non-empty classes
                print(f"  {class_name.upper()}: {len(meds)} medications")
                for med in meds:
                    brands = med_dict.medications[med].brand_names
                    brand_str = f" ({', '.join(brands)})" if brands else ""
                    print(f"    - {med.title()}{brand_str}")
    elif args.find_meds:
        # Find medications in a text file
        med_dict = MedDictionary()
        try:
            with open(args.find_meds, 'r', encoding='utf-8') as f:
                text = f.read()

            meds = med_dict.find_medication_mentions(text)
            if meds:
                print(f"Found {len(meds)} medications:")
                for med in meds:
                    med_class = med_dict.get_medication_class(med)
                    print(f"  - {med.title()} ({med_class.upper()})")
            else:
                print("No medications found in the text.")
        except Exception as e:
            print(f"Error reading file: {e}")
    else:
        # Print some info
        med_dict = MedDictionary()
        print(f"Loaded {len(med_dict.medications)} medications")
        print(f"SSRIs: {', '.join(med_dict.classes['ssri'])}")
        print(f"SNRIs: {', '.join(med_dict.classes['snri'])}")

        # Export to CSV
        med_dict.export_csv("medications.csv")

        # Get all names for searching
        all_names = med_dict.get_all_medication_names()
        print(f"Total search terms: {len(all_names)}")
        print(f"Sample terms: {', '.join(sorted(all_names)[:10])}")

    def import_csv(self, filename: Path | str) -> bool:
        """
        Import medications from a CSV file
        Args:
            filename: Path to the input CSV file

        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Read the CSV file
            with open(filename, 'r', newline='', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                rows = list(reader)  # Read all rows to process in batch

            # Process all rows
            skipped_rows = []
            success_count = 0

            for i, row in enumerate(rows):
                try:
                    med_data = {
                        'generic_name': row['generic_name'],
                        'brand_names': [b.strip() for b in row.get('brand_names', '').split(',') if b.strip()],
                        'drug_class': row['drug_class'],
                        'aliases': [a.strip() for a in row.get('aliases', '').split(',') if a.strip()],
                        'notes': row.get('notes', '')
                    }
                    self._add_medication(med_data)
                    success_count += 1
                except ValueError as e:
                    # Log the error and skip this row
                    logger.warning(f"Skipped row {i+1} ({row.get('generic_name', 'unknown')}): {e}")
                    skipped_rows.append((i+1, row.get('generic_name', 'unknown'), str(e)))
                except KeyError as e:
                    logger.warning(f"Skipped row {i+1}: Missing required field {e}")
                    skipped_rows.append((i+1, row.get('generic_name', 'unknown'), f"Missing required field {e}"))

            # Report results
            if skipped_rows:
                logger.warning(f"Imported {success_count} medications, skipped {len(skipped_rows)} rows with errors")
                for row_num, name, error in skipped_rows:
                    logger.warning(f"  Row {row_num}: {name} - {error}")
            else:
                logger.info(f"Successfully imported all {success_count} medications from {filename}")

            return success_count > 0

        except Exception as e:
            logger.error(f"Failed to import medications from CSV: {e}")
            return False

    # Removing incomplete method stub
